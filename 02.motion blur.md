

# 2. ëª¨ì…˜ ë¸”ëŸ¬

ë ˆì´íŠ¸ ë ˆì´ì‹±ì„ ê²°ì •í–ˆì„ ë•Œ ì‹œê°ì  í’ˆì§ˆì´ ëŸ°íƒ€ì„ë³´ë‹¤ ë” ê°€ì¹˜ê°€ ìˆë‹¤ê³  ê²°ì •í–ˆìŠµë‹ˆë‹¤. í¼ì§€ ë°˜ì‚¬ ë° ë”” í¬ì»¤ìŠ¤ ë¸”ëŸ¬ì—ëŠ” í”½ì…€ ë‹¹ ì—¬ëŸ¬ ìƒ˜í”Œì´ í•„ìš”í–ˆìŠµë‹ˆë‹¤. ì¼ë‹¨ ê·¸ ê¸¸ì„ ë”°ë¼ ë‚´ë ¤ ê°€ë©´ ì¢‹ì€ ì†Œì‹ì€ ê±°ì˜ ëª¨ë“  íš¨ê³¼ê°€ ë¬´ì°¨ë³„ ëŒ€ì… ë  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ëª¨ì…˜ ë¸”ëŸ¬ëŠ” í™•ì‹¤íˆ ê·¸ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤. ì‹¤ì œ ì¹´ë©”ë¼ì—ì„œëŠ” ì…”í„°ê°€ ì¼ì • ì‹œê°„ ë™ì•ˆ ì—´ë¦¬ê³  ì—´ë ¤ ìˆìœ¼ë©° ê·¸ ì‹œê°„ ë™ì•ˆ ì¹´ë©”ë¼ì™€ ë¬¼ì²´ê°€ ì›€ì§ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìš°ë¦¬ê°€ ì›í•˜ëŠ” ê°„ê²© ë™ì•ˆ ì¹´ë©”ë¼ê°€ ë³´ëŠ” ê²ƒì˜ í‰ê· ì…ë‹ˆë‹¤.



## 2.1 SpaceTime Ray Tracing ì†Œê°œ

ì…”í„°ê°€ ì—´ë ¤ìˆì„ ë•Œ ì„ì˜ì˜ ì‹œê°„ì— ê° ê´‘ì„ ì„ ì „ì†¡í•˜ì—¬ ì„ì˜ì˜ ì¶”ì •ì¹˜ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¬¼ì²´ê°€ ê·¸ ì‹œê°„ì— ìˆì–´ì•¼ í•  ê³³ì—ìˆëŠ” í•œ ì •í™•íˆ í•œ ë²ˆì—ìˆëŠ” ê´‘ì„ ìœ¼ë¡œ ì˜¬ë°”ë¥¸ í‰ê·  ë‹µì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì´ ëœë¤ ë ˆì´ íŠ¸ë ˆì´ì‹±ì´ ë‹¨ìˆœí•œ ê²½í–¥ì´ìˆëŠ” ê·¼ë³¸ì ì¸ ì´ìœ ì…ë‹ˆë‹¤.

ê¸°ë³¸ ì•„ì´ë””ì–´ëŠ” ì…”í„°ê°€ ì—´ë ¤ìˆëŠ” ë™ì•ˆ ì„ì˜ì˜ ì‹œê°„ì— ê´‘ì„ ì„ ìƒì„±í•˜ê³  í•œ ë²ˆì— ëª¨ë¸ê³¼ êµì°¨í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ìˆ˜í–‰ë˜ëŠ” ë°©ë²•ì€ ì¹´ë©”ë¼ë¥¼ ì›€ì§ì´ê³  ì˜¤ë¸Œì íŠ¸ë¥¼ ì›€ì§ì´ì§€ë§Œ ê° ê´‘ì„ ì´ ì •í™•íˆ í•œ ë²ˆì— ì¡´ì¬í•˜ë„ë¡í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ëŸ° ì‹ìœ¼ë¡œ ê´‘ì„  ì¶”ì ê¸°ì˜ "ì—”ì§„"ì€ ê°ì²´ê°€ ê´‘ì„ ì— í•„ìš”í•œ ìœ„ì¹˜ì— ìˆëŠ”ì§€ í™•ì¸í•˜ê³  êµì°¨ ê±°íŠ¸ëŠ” ë§ì´ ë³€ê²½ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.


ì´ë¥¼ ìœ„í•´ ë¨¼ì € ë‹¤ìŒê³¼ ê°™ì´ rayì— ê·¸ê²ƒì´ ì¡´ì¬í•œ ì‹œê°„ì„ ì €ì¥í•©ë‹ˆë‹¤.


```c++
class ray {
    public:
        ray() {}
        /* ìˆ˜ì • */
        ray(const point3& origin, const vec3& direction, double time = 0.0)
            : orig(origin), dir(direction), tm(time)
        {}
        /*******/

        point3 origin() const  { return orig; }
        vec3 direction() const { return dir; }
        /* ì¶”ê°€ */
        double time() const    { return tm; }
        /*******/

        point3 at(double t) const {
            return orig + t*dir;
        }

    public:
        point3 orig;
        vec3 dir;
        /* ì¶”ê°€ */
        double tm;};
        /*******/
```

**ëª©ë¡ 1 :** [ray.h] ì‹œê°„ ì •ë³´ê°€ìˆëŠ” Ray







## 2.2 ëª¨ì…˜ ë¸”ëŸ¬ ì‹œë®¬ë ˆì´ì…˜ì„ìœ„í•œ ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸

ì´ì œ `time1`ê³¼ `time2` ì‚¬ì´ì— ì„ì˜ì˜ ì‹œê°„ì— ê´‘ì„ ì„ ìƒì„±í•˜ë„ë¡ ì¹´ë©”ë¼ë¥¼ ìˆ˜ì •í•´ì•¼í•©ë‹ˆë‹¤..
ì¹´ë©”ë¼ê°€ `time1`ê³¼ `time2`ë¥¼ ì¶”ì í•´ì•¼í•©ë‹ˆê¹Œ? ì•„ë‹ˆë©´ ê´‘ì„ ì´ ìƒì„± ë  ë•Œ ì¹´ë©”ë¼ ì‚¬ìš©ìê°€ ì´ë¥¼ ì¶”ì í•´ì•¼í•©ë‹ˆê¹Œ? í™•ì‹¤í•˜ì§€ ì•Šì€ ê²½ìš° ì €ëŠ” í˜¸ì¶œì„ ê°„ë‹¨í•˜ê²Œ ë§Œë“¤ê¸° ìœ„í•´ ìƒì„±ìë¥¼ ë³µì¡í•˜ê²Œ ë§Œë“œëŠ” ê²ƒì„ ì¢‹ì•„í•˜ë¯€ë¡œ ì¹´ë©”ë¼ê°€ ê³„ì† ì¶”ì í•˜ë„ë¡ í•  ê²ƒì…ë‹ˆë‹¤.í•˜ì§€ë§Œ ê·¸ê²ƒì€ ê°œì¸ì ì¸ ì·¨í–¥ì…ë‹ˆë‹¤. ì§€ê¸ˆì€ ì›€ì§ì¼ ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— ì¹´ë©”ë¼ë¥¼ ë§ì´ ë³€ê²½í•  í•„ìš”ëŠ” ì—†ìŠµë‹ˆë‹¤. ì¼ì • ê¸°ê°„ ë™ì•ˆ ê´‘ì„  ë§Œ ë‚´ ë³´ëƒ…ë‹ˆë‹¤.

```cpp
class camera {
    public:
        camera(
            point3 lookfrom,
            point3 lookat,
            vec3   vup,
            double vfov, // vertical field-of-view in degrees
            double aspect_ratio,
            double aperture,
            double focus_dist,
            /* ì¶”ê°€ */
            double _time0 = 0,
            double _time1 = 0
            /*******/
        ) {
            auto theta = degrees_to_radians(vfov);
            auto h = tan(theta/2);
            auto viewport_height = 2.0 * h;
            auto viewport_width = aspect_ratio * viewport_height;

            w = unit_vector(lookfrom - lookat);
            u = unit_vector(cross(vup, w));
            v = cross(w, u);

            origin = lookfrom;
            horizontal = focus_dist * viewport_width * u;
            vertical = focus_dist * viewport_height * v;
            lower_left_corner = origin - horizontal/2 - vertical/2 - focus_dist*w;

            lens_radius = aperture / 2;
            /* ì¶”ê°€ */
            time0 = _time0;
            time1 = _time1;
            /*******/
        }

        ray get_ray(double s, double t) const {
            vec3 rd = lens_radius * random_in_unit_disk();
            vec3 offset = u * rd.x() + v * rd.y();

            return ray(
                origin + offset,
                /* ìˆ˜ì • */
                lower_left_corner + s*horizontal + t*vertical - origin - offset,
                random_double(time0, time1)
                /*******/
            );
        }

    private:
        point3 origin;
        point3 lower_left_corner;
        vec3 horizontal;
        vec3 vertical;
        vec3 u, v, w;
        double lens_radius;
        /* ì¶”ê°€ */
        double time0, time1;  // shutter open/close times};
        /*******/
```

**ëª©ë¡ 2 :** [camera.h] ì‹œê°„ ì •ë³´ê°€ìˆëŠ” ì¹´ë©”ë¼

## 2.3 ì›€ì§ì´ëŠ” êµ¬ì²´ ì¶”ê°€

ì›€ì§ì´ëŠ” ë¬¼ì²´ë„ í•„ìš”í•©ë‹ˆë‹¤. ì¤‘ì‹¬ì´ `time0`ì¼ ë•Œ, `center0`ì—ì„œ `time1`ì¼ ë•Œ, `center1`ë¡œ ì„ í˜•ìœ¼ë¡œ ì´ë™í•˜ëŠ” êµ¬í˜• í´ë˜ìŠ¤ë¥¼ ë§Œë“­ë‹ˆë‹¤. ì´ ì‹œê°„ ê°„ê²©ì„ ë²—ì–´ë‚˜ë©´ ê³„ì† ì‘ë™í•˜ë¯€ë¡œ ì¹´ë©”ë¼ ì¡°ë¦¬ê°œë¥¼ ì—´ê³  ë‹«ì„ ë•Œ ì‹œê°„ì„ ë§ì¶œ í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.

```cpp
#ifndef MOVING_SPHERE_H
#define MOVING_SPHERE_H

#include "rtweekend.h"

#include "hittable.h"


class moving_sphere : public hittable {
    public:
        moving_sphere() {}
        moving_sphere(
            point3 cen0, point3 cen1, double _time0, double _time1, double r, shared_ptr<material> m)
            : center0(cen0), center1(cen1), time0(_time0), time1(_time1), radius(r), mat_ptr(m)
        {};

        virtual bool hit(
            const ray& r, double t_min, double t_max, hit_record& rec) const override;

        point3 center(double time) const;

    public:
        point3 center0, center1;
        double time0, time1;
        double radius;
        shared_ptr<material> mat_ptr;
};

point3 moving_sphere::center(double time) const {
    return center0 + ((time - time0) / (time1 - time0))*(center1 - center0);
}

#endif
```

**ëª©ë¡ 3 :** [moving_sphere.h] ì›€ì§ì´ëŠ” êµ¬ì²´


ìƒˆë¡œìš´ ì›€ì§ì´ëŠ” êµ¬ì²´ í´ë˜ìŠ¤ë¥¼ ë§Œë“œëŠ” ëŒ€ì•ˆì€ ëª¨ë‘ ì›€ì§ì´ê²Œí•˜ëŠ” ë°˜ë©´ ê³ ì • êµ¬ì²´ëŠ” ë™ì¼í•œ ì‹œì‘ ë° ë ìœ„ì¹˜ë¥¼ ê°–ìŠµë‹ˆë‹¤. ë‚˜ëŠ” ë” ì ì€ ìˆ˜ì˜ í´ë˜ìŠ¤ì™€ ë” íš¨ìœ¨ì ì¸ ê³ ì • ëœ êµ¬ì²´ ì‚¬ì´ì˜ ì ˆì¶©ì•ˆì— ëŒ€í•´ ìƒê°í•˜ê³  ìˆìœ¼ë¯€ë¡œ ë‹¹ì‹ ì˜ ë””ìì¸ ì·¨í–¥ì— ë§ê²Œ ì„ íƒí•˜ë©´ ë©ë‹ˆë‹¤.

`moving_sphere :: hit ()` í•¨ìˆ˜ëŠ” `sphere :: hit ()` í•¨ìˆ˜ì™€ ê±°ì˜ ë™ì¼í•©ë‹ˆë‹¤. `center`ëŠ” í•¨ìˆ˜ `center(time)`ê°€ ë˜ê¸°ë§Œí•˜ë©´ ë©ë‹ˆë‹¤.

```cpp
bool moving_sphere::hit(const ray& r, double t_min, double t_max, hit_record& rec) const {
    /* ì¶”ê°€ */
    vec3 oc = r.origin() - center(r.time());
    /*******/
    auto a = r.direction().length_squared();
    auto half_b = dot(oc, r.direction());
    auto c = oc.length_squared() - radius*radius;

    auto discriminant = half_b*half_b - a*c;
    if (discriminant < 0) return false;
    auto sqrtd = sqrt(discriminant);

    // Find the nearest root that lies in the acceptable range.
    auto root = (-half_b - sqrtd) / a;
    if (root < t_min || t_max < root) {
        root = (-half_b + sqrtd) / a;
        if (root < t_min || t_max < root)
            return false;
    }

    rec.t = root;
    rec.p = r.at(rec.t);
    /* ì¶”ê°€ */
    auto outward_normal = (rec.p - center(r.time())) / radius;
    /*******/
    rec.set_face_normal(r, outward_normal);
    rec.mat_ptr = mat_ptr;

    return true;
}
```

**ëª©ë¡ 4 :** [moving_sphere.h] ë¬´ë¹™ ìŠ¤í”¼ì–´ íˆíŠ¸ í•¨ìˆ˜



## 2.4 ê´‘ì„  êµì°¨ ì‹œê°„ ì¶”ì 


ì´ì œ ê´‘ì„ ì— ì‹œê°„ ì†ì„±ì´ ìˆìœ¼ë¯€ë¡œ `material::scatter()`êµì°¨ ì‹œê°„ì„ ê³ ë ¤ í•˜ì—¬ ë©”ì„œë“œë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼ í•©ë‹ˆë‹¤.



```cpp
class lambertian : public material {
    ...
        virtual bool scatter(
            const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered
        ) const override {
            auto scatter_direction = rec.normal + random_unit_vector();

            // Catch degenerate scatter direction
            if (scatter_direction.near_zero())
                scatter_direction = rec.normal;

            /* ìˆ˜ì • */
            scattered = ray(rec.p, scatter_direction, r_in.time());
            /*******/
            attenuation = albedo;
            return true;
        }
        ...
};

class metal : public material {
    ...
        virtual bool scatter(
            const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered
        ) const override {
            vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal);
            /* ìˆ˜ì • */
            scattered = ray(rec.p, reflected + fuzz*random_in_unit_sphere(), r_in.time());
            /*******/
            attenuation = albedo;
            return (dot(scattered.direction(), rec.normal) > 0);
        }
        ...
};

class dielectric : public material {
    ...
        virtual bool scatter(
            ...
            /* ìˆ˜ì • */
            scattered = ray(rec.p, direction, r_in.time());
            /*******/
            return true;
        }
        ...
};
```

**ëª©ë¡ 5 :** [material.h] material :: scatter () ë©”ì„œë“œì—ì„œ ê´‘ì„  ì‹œê°„ ì²˜ë¦¬







## 2.5 ëª¨ë“  ê²ƒì„ í†µí•©í•˜ê¸°


ì•„ë˜ ì½”ë“œëŠ” ì´ì „ ì±…(raytracing in oneweekendì˜ ë ë¶€ë¶„ì—ìˆëŠ” ì¥ë©´ì—ì„œ í™•ì‚° êµ¬ì˜ ì˜ˆë¥¼ ê°€ì ¸ ì™€ì„œ ì´ë¯¸ì§€ ë Œë”ë§ ì¤‘ì— ì´ë™í•˜ê²Œí•©ë‹ˆë‹¤. (ì‹œê°„ 0ì— ì…”í„°ê°€ ì—´ë¦¬ê³  ì‹œê°„ 1ì— ë‹«íˆëŠ” ì¹´ë©”ë¼ë¥¼ ìƒê°í•´ë³´ì‹­ì‹œì˜¤.) ê° êµ¬ëŠ” ì‹œê°„ ğ‘¡ = 0ì¼ ë•Œ, ì¤‘ì‹¬ ğ‚ì—ì„œ ì‹œê°„ ğ‘¡ = 1 ì¼ ë•Œ, ì¤‘ì‹¬ ğ‚ + (0, ğ‘Ÿ / 2,0)ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œ ğ‘Ÿì€ [0,1)ë²”ìœ„ì˜ ë‚œìˆ˜ì…ë‹ˆë‹¤.:

```cpp
...
/* ì¶”ê°€ */
#include "moving_sphere.h"
/*******/
...
hittable_list random_scene() {
    hittable_list world;

    auto ground_material = make_shared<lambertian>(color(0.5, 0.5, 0.5));
    world.add(make_shared<sphere>(point3(0,-1000,0), 1000, ground_material));

    for (int a = -11; a < 11; a++) {
        for (int b = -11; b < 11; b++) {
            auto choose_mat = random_double();
            point3 center(a + 0.9*random_double(), 0.2, b + 0.9*random_double());

            if ((center - vec3(4, 0.2, 0)).length() > 0.9) {
                shared_ptr<material> sphere_material;

                if (choose_mat < 0.8) {
                    // diffuse
                    auto albedo = color::random() * color::random();
                    sphere_material = make_shared<lambertian>(albedo);
                    /* ì¶”ê°€ */
                    auto center2 = center + vec3(0, random_double(0,.5), 0);
                    world.add(make_shared<moving_sphere>(
                        center, center2, 0.0, 1.0, 0.2, sphere_material));                }
                    /*******/

                    else if (choose_mat < 0.95) {
                    // metal
                    auto albedo = color::random(0.5, 1);
                    auto fuzz = random_double(0, 0.5);
                    sphere_material = make_shared<metal>(albedo, fuzz);
                    world.add(make_shared<sphere>(center, 0.2, sphere_material));
                } else {
                    // glass
                    sphere_material = make_shared<dielectric>(1.5);
                    world.add(make_shared<sphere>(center, 0.2, sphere_material));
                }
            }
        }
    }

    auto material1 = make_shared<dielectric>(1.5);
    world.add(make_shared<sphere>(point3(0, 1, 0), 1.0, material1));

    auto material2 = make_shared<lambertian>(color(0.4, 0.2, 0.1));
    world.add(make_shared<sphere>(point3(-4, 1, 0), 1.0, material2));

    auto material3 = make_shared<metal>(color(0.7, 0.6, 0.5), 0.0);
    world.add(make_shared<sphere>(point3(4, 1, 0), 1.0, material3));

    return world;
}
```
**ëª©ë¡ 6 :** [main.cc] ì§€ë‚œ ì±…ì˜ ë§ˆì§€ë§‰ ì¥ë©´, ì›€ì§ì´ëŠ” êµ¬ì²´

ê·¸ë¦¬ê³  ì´ëŸ¬í•œ viewing ë§¤ê°œ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ :


```cpp
int main() {

    // Image

    /* ìˆ˜ì • */
    auto aspect_ratio = 16.0 / 9.0;
    int image_width = 400;
    int samples_per_pixel = 100;
    const int max_depth = 50;
    /*******/

    ...

    // Camera

    point3 lookfrom(13,2,3);
    point3 lookat(0,0,0);
    vec3 vup(0,1,0);
    auto dist_to_focus = 10.0;
    auto aperture = 0.1;
    /* ìˆ˜ì • */
    int image_height = static_cast<int>(image_width / aspect_ratio);

    camera cam(lookfrom, lookat, vup, 20, aspect_ratio, aperture, dist_to_focus, 0.0, 1.0);
    /*******/
```

**ëª©ë¡ 7 :** [main.cc] viewing ë§¤ê°œë³€ìˆ˜

ë‹¤ìŒ ê²°ê³¼ë¥¼ ì œê³µí•©ë‹ˆë‹¤.


[![img](https://raytracing.github.io/images/img-2.01-bouncing-spheres.png)](https://raytracing.github.io/images/img-2.01-bouncing-spheres.png)

*ì´ë¯¸ì§€ 1 : íŠ€ëŠ” êµ¬ì²´*
