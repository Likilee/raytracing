# 4. ì†”ë¦¬ë“œ í…ìŠ¤ì²˜

ê·¸ë˜í”½ì˜ í…ìŠ¤ì²˜ëŠ” ì¼ë°˜ì ìœ¼ë¡œ í‘œë©´ì˜ ìƒ‰ìƒì„ ì ˆì°¨ ì ìœ¼ë¡œ ë§Œë“œëŠ” ê¸°ëŠ¥ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì´ ì ˆì°¨ëŠ” í•©ì„± ì½”ë“œì´ê±°ë‚˜ ì´ë¯¸ì§€ ì¡°íšŒ ë˜ëŠ” ë‘ ê°€ì§€ì˜ ì¡°í•© ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¨¼ì € ëª¨ë“  ìƒ‰ìƒì„ í…ìŠ¤ì²˜ë¡œ ë§Œë“­ë‹ˆë‹¤. ëŒ€ë¶€ë¶„ì˜ í”„ë¡œê·¸ë¨ì€ ê· ì¼í•œ rgb ìƒ‰ìƒê³¼ í…ìŠ¤ì²˜ë¥¼ ì„œë¡œ ë‹¤ë¥¸ í´ë˜ìŠ¤ë¡œ ìœ ì§€í•˜ë¯€ë¡œ ììœ ë¡­ê²Œ ë‹¤ë¥¸ ì‘ì—…ì„ ìˆ˜í–‰ í•  ìˆ˜ ìˆì§€ë§Œ ì–´ë–¤ ìƒ‰ìƒì´ë“  í…ìŠ¤ì²˜ë¡œ ë§Œë“¤ ìˆ˜ ìˆë‹¤ëŠ” ì ì—ì„œ ì €ëŠ” ì´ ì•„í‚¤í…ì²˜ë¥¼ ë§¤ìš° ì‹ ë´‰í•©ë‹ˆë‹¤.


## 4.1 ì²« ë²ˆì§¸ í…ìŠ¤ì²˜ í´ë˜ìŠ¤ : ìƒìˆ˜ í…ìŠ¤ì²˜

```cpp
#ifndef TEXTURE_H
#define TEXTURE_H

#include "rtweekend.h"

class texture {
    public:
        virtual color value(double u, double v, const point3& p) const = 0;
};

class solid_color : public texture {
    public:
        solid_color() {}
        solid_color(color c) : color_value(c) {}

        solid_color(double red, double green, double blue)
          : solid_color(color(red,green,blue)) {}

        virtual color value(double u, double v, const vec3& p) const override {
            return color_value;
        }

    private:
        color color_value;
};

#endif
```

**ëª©ë¡ 20 :** [texture.h] í…ìŠ¤ì²˜ í´ë˜ìŠ¤

ê´‘ì„  ì˜¤ë¸Œì íŠ¸ íˆíŠ¸ í¬ì¸íŠ¸ì˜ U, V í‘œë©´ ì¢Œí‘œë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ `hit_record` êµ¬ì¡°ë¥¼ ì—…ë°ì´íŠ¸í•´ì•¼í•©ë‹ˆë‹¤.

```cpp
struct hit_record {
    vec3 p;
    vec3 normal;
    shared_ptr<material> mat_ptr;
    double t;
    /* ì¶”ê°€ */
    double u;
    double v;
    /*******/
    bool front_face;
    ...
```

**ëª©ë¡ 21 :** [hittable.h] U, V ì¢Œí‘œë¥¼ `hit_record`ì— ì¶”ê°€.


ë˜í•œ íˆíŠ¸ í…Œì´ë¸”ì— ëŒ€í•œ (ğ‘¢, ğ‘£) í…ìŠ¤ì²˜ ì¢Œí‘œë¥¼ ê³„ì‚°í•´ì•¼ í•©ë‹ˆë‹¤.


## 4.2 êµ¬ì˜ í…ìŠ¤ì²˜ ì¢Œí‘œ

êµ¬ì˜ ê²½ìš° í…ìŠ¤ì²˜ ì¢Œí‘œëŠ” ì¼ë°˜ì ìœ¼ë¡œ ì¼ì¢…ì˜ ê²½ë„ ë° ìœ„ë„, ì¦‰ êµ¬ë©´ ì¢Œí‘œë¥¼ ê¸°ë°˜ìœ¼ë¡œí•©ë‹ˆë‹¤. ê·¸ë˜ì„œ ìš°ë¦¬ëŠ” êµ¬ë©´ ì¢Œí‘œì—ì„œ (ğœƒ, ğœ™)ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œ ğœƒëŠ” ë°”ë‹¥ ê·¹ë¶€í„° ìœ„ìª½ìœ¼ë¡œì˜ ê°ë„ (ì¦‰, -Yì—ì„œ ìœ„ìª½ìœ¼ë¡œ)ì´ê³ , ğœ™ëŠ” Y ì¶• ì£¼ìœ„ì˜ ê°ë„ (-X to Z to +X to -Z back to -X[xz í‰ë©´]).
ğœƒ ë° ğœ™ë¥¼ [0,1] ë²”ìœ„ì˜ í…ìŠ¤ì²˜ ì¢Œí‘œ ğ‘¢ ë° ğ‘£ì— ê°ê° ë§¤í•‘í•˜ë ¤ê³ í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œ (ğ‘¢ = 0, ğ‘£ = 0)ì€ í…ìŠ¤ì²˜ì˜ ì™¼ìª½ í•˜ë‹¨ ëª¨ì„œë¦¬ì— ë§¤í•‘ë©ë‹ˆë‹¤. ë”°ë¼ì„œ (ğœƒ, ğœ™)ì—ì„œ (ğ‘¢, ğ‘£) ë¡œì˜ ì •ê·œí™”ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.

![ğ‘¢ = ğœ™2ğœ‹](https://latex.codecogs.com/svg.latex?u%20=%20\frac{\phi}{2\pi})

![ğ‘£ = ğœƒğœ‹](https://latex.codecogs.com/svg.latex?v%20=%20\frac{\theta}{\pi})

ì›ì ì„ ì¤‘ì‹¬ìœ¼ë¡œí•˜ëŠ” ë‹¨ìœ„ êµ¬ì˜ ì£¼ì–´ì§„ ì ì— ëŒ€í•´ ğœƒ ë° ğœ™ë¥¼ ê³„ì‚°í•˜ë ¤ë©´ í•´ë‹¹í•˜ëŠ” ë°ì¹´ë¥´íŠ¸ ì¢Œí‘œì— ëŒ€í•œ ë°©ì •ì‹ìœ¼ë¡œ ì‹œì‘í•©ë‹ˆë‹¤.

![ğ‘¦ğ‘¥ğ‘§ = âˆ’cos (ğœƒ) = âˆ’ cos (ğœ™) sin (ğœƒ) = sin (ğœ™) sin (ğœƒ)](https://latex.codecogs.com/svg.latex?\begin{align*}%20%20%20%20%20%20y%20&=%20-\cos(\theta)%20%20%20%20%20%20%20%20%20%20%20%20\%20%20%20%20%20%20x%20&=%20-\cos(\phi)%20\sin(\theta)%20\%20%20%20%20%20%20z%20&=%20\quad\sin(\phi)%20\sin(\theta)%20%20%20%20%20\end{align*})

ğœƒê³¼ ğœ™ë¥¼ í’€ë ¤ë©´ì´ ë°©ì •ì‹ì„ ë°˜ì „ì‹œì¼œì•¼í•©ë‹ˆë‹¤. ì‚¬ì¸ê³¼ ì½”ì‚¬ì¸ì— ë¹„ë¡€í•˜ëŠ” ìˆ«ì ìŒì„ ì·¨í•˜ê³  ê°ë„ë¥¼ ë°˜í™˜í•˜ëŠ” ì‚¬ë‘ìŠ¤ëŸ¬ìš´ <cmath> í•¨ìˆ˜ atan2 () ë•Œë¬¸ì— ğ‘¥ ë° ğ‘§ (sin (ğœƒ) ì·¨ì†Œ)ë¥¼ ì „ë‹¬í•˜ì—¬ ğœ™ë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

![ğœ™ = atan2 (ğ‘§, âˆ’ğ‘¥)](https://latex.codecogs.com/svg.latex?\phi%20=%20\text{atan2}(z,%20-x))

atan2 ()ëŠ” âˆ’ğœ‹ ~ ğœ‹ ë²”ìœ„ì˜ ê°’ì„ ë°˜í™˜í•˜ì§€ë§Œ 0ì—ì„œ ğœ‹ê¹Œì§€ ì´ë™ í•œ ë‹¤ìŒ âˆ’ğœ‹ë¡œ ë’¤ì§‘ê³  0ìœ¼ë¡œ ë‹¤ì‹œ ì§„í–‰í•©ë‹ˆë‹¤. ì´ê²ƒì€ ìˆ˜í•™ì ìœ¼ë¡œ ì •í™•í•˜ì§€ë§Œ ğ‘¢ì˜ ë²”ìœ„ëŠ” 0ì—ì„œ 1/2ê¹Œì§€ê°€ ì•„ë‹Œ 0ì—ì„œ 1ê¹Œì§€, ê·¸ë¦¬ê³  ë‚˜ì„œ âˆ’1/2ì—ì„œ 0ê¹Œì§€ì…ë‹ˆë‹¤. ë‹¤í–‰íˆë„,

![atan2 (ğ‘, ğ‘) = atan2 (âˆ’ğ‘, âˆ’ğ‘) + ğœ‹](https://latex.codecogs.com/svg.latex?\text{atan2}(a,b)%20=%20\text{atan2}(-a,-b)%20+%20\pi,)

ë‘ ë²ˆì§¸ ê³µì‹ì€ ì—°ì†ì ìœ¼ë¡œ 0ì—ì„œ 2ğœ‹ê¹Œì§€ì˜ ê°’ì„ ì‚°ì¶œí•©ë‹ˆë‹¤. ë”°ë¼ì„œ ğœ™ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ê³„ì‚°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

![ğœ™ = atan2 (âˆ’ğ‘§, ğ‘¥) + ğœ‹](https://latex.codecogs.com/svg.latex?\phi%20=%20\text{atan2}(-z,%20x)%20+%20\pi)

ğœƒì˜ íŒŒìƒì€ ë” ê°„ë‹¨í•©ë‹ˆë‹¤.

![ğœƒ = acos (âˆ’ğ‘¦)](https://latex.codecogs.com/svg.latex?\theta%20=%20\text{acos}(-y))

ë”°ë¼ì„œ êµ¬ì˜ ê²½ìš° (ğ‘¢, ğ‘£) ì¢Œí‘œ ê³„ì‚°ì€ ì›ì ì„ ì¤‘ì‹¬ìœ¼ë¡œí•˜ëŠ” ë‹¨ìœ„ êµ¬ì˜ ì ì„ ì·¨í•˜ê³  ğ‘¢ ë° ğ‘£ë¥¼ ê³„ì‚°í•˜ëŠ” ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ì— ì˜í•´ ìˆ˜í–‰ë©ë‹ˆë‹¤.


```cpp
class sphere : public hittable {
    ...
    private:
        static void get_sphere_uv(const point3& p, double& u, double& v) {
            // p: a given point on the sphere of radius one, centered at the origin.
            // u: returned value [0,1] of angle around the Y axis from X=-1.
            // v: returned value [0,1] of angle from Y=-1 to Y=+1.
            //     <1 0 0> yields <0.50 0.50>       <-1  0  0> yields <0.00 0.50>
            //     <0 1 0> yields <0.50 1.00>       < 0 -1  0> yields <0.50 0.00>
            //     <0 0 1> yields <0.25 0.50>       < 0  0 -1> yields <0.75 0.50>

            auto theta = acos(-p.y());
            auto phi = atan2(-p.z(), p.x()) + pi;

            u = phi / (2*pi);
            v = theta / pi;
        }
};
```

**ëª©ë¡ 22 :** [sphere.h] get_sphere_uv í•¨ìˆ˜

ì´ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ íˆíŠ¸ ë ˆì½”ë“œ UV ì¢Œí‘œë¥¼ ì—…ë°ì´íŠ¸í•˜ê¸° ìœ„í•´ `sphere :: hit ()` í•¨ìˆ˜ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

```cpp
bool sphere::hit(...) {
    ...

    rec.t = root;
    rec.p = r.at(rec.t);
    vec3 outward_normal = (rec.p - center) / radius;
    rec.set_face_normal(r, outward_normal);
    /* ì¶”ê°€ */
    get_sphere_uv(outward_normal, rec.u, rec.v);
    /*******/

    rec.mat_ptr = mat_ptr;

    return true;
}
```

**ëª©ë¡ 23 :** [sphere.h] íˆíŠ¸ì—ì„œ êµ¬ UV ì¢Œí‘œ

ì´ì œ `const color & a`ë¥¼ í…ìŠ¤ì²˜ í¬ì¸í„°ë¡œ ëŒ€ì²´í•˜ì—¬ í…ìŠ¤ì²˜ ì¬ì§ˆì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.



```cpp
/* ì¶”ê°€ */
#include "texture.h"
/*******/

...
class lambertian : public material {
    public:
        /* ìˆ˜ì • */
        lambertian(const color& a) : albedo(make_shared<solid_color>(a)) {}
        lambertian(shared_ptr<texture> a) : albedo(a) {}
        /*******/

        virtual bool scatter(
            const ray& r_in, const hit_record& rec, color& attenuation, ray& scattered
        ) const override {
            auto scatter_direction = rec.normal + random_unit_vector();

            // Catch degenerate scatter direction
            if (scatter_direction.near_zero())
                scatter_direction = rec.normal;

            scattered = ray(rec.p, scatter_direction, r_in.time());
            /* ìˆ˜ì • */
            attenuation = albedo->value(rec.u, rec.v, rec.p);
            /*******/
            return true;
        }

    public:
        /* ìˆ˜ì • */
        shared_ptr<texture> albedo;};
        /*******/
```

**ëª©ë¡ 24 :** [material.h] í…ìŠ¤ì²˜ê°€ìˆëŠ” Lambertian ì¬ì§ˆ


## 4.3 ì²´í¬ ë¬´ëŠ¬ í…ìŠ¤ì²˜

ì‚¬ì¸ê³¼ ì½”ì‚¬ì¸ì˜ ë¶€í˜¸ê°€ ê·œì¹™ì ìœ¼ë¡œ ë²ˆê°ˆì•„ ê°€ë©° 3 ì°¨ì› ëª¨ë‘ì—ì„œ ì‚¼ê° í•¨ìˆ˜ë¥¼ ê³±í•˜ë©´ í•´ë‹¹ ì œí’ˆì˜ ë¶€í˜¸ê°€ 3D ì²´í¬ ë¬´ëŠ¬ íŒ¨í„´ì„ í˜•ì„±í•œë‹¤ëŠ” ì ì— ì£¼ëª©í•˜ì—¬ ì²´í¬ ë¬´ëŠ¬ í…ìŠ¤ì²˜ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```cpp
class checker_texture : public texture {
    public:
        checker_texture() {}

        checker_texture(shared_ptr<texture> _even, shared_ptr<texture> _odd)
            : even(_even), odd(_odd) {}

        checker_texture(color c1, color c2)
            : even(make_shared<solid_color>(c1)) , odd(make_shared<solid_color>(c2)) {}

        virtual color value(double u, double v, const point3& p) const override {
            auto sines = sin(10*p.x())*sin(10*p.y())*sin(10*p.z());
            if (sines < 0)
                return odd->value(u, v, p);
            else
                return even->value(u, v, p);
        }

    public:
        shared_ptr<texture> odd;
        shared_ptr<texture> even;
};
```

**ëª©ë¡ 25 :** [texture.h] ì²´í¬ ë¬´ëŠ¬ í…ìŠ¤ì²˜

ê²€ì‚¬ê¸° í™€ìˆ˜ / ì§ìˆ˜ í¬ì¸í„°ëŠ” ì¼ì •í•œ í…ìŠ¤ì²˜ ë˜ëŠ” ë‹¤ë¥¸ ì ˆì°¨ ì  í…ìŠ¤ì²˜ì— ëŒ€í•œ ê²ƒì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ 1980 ë…„ëŒ€ì— Pat Hanrahanì´ ì†Œê°œ í•œ ì…°ì´ë” ë„¤íŠ¸ì›Œí¬ì˜ ì •ì‹ ì…ë‹ˆë‹¤.

`random_scene ()` í•¨ìˆ˜ì˜ ê¸°ë³¸ êµ¬ì— ì´ê²ƒì„ ì¶”ê°€í•˜ë©´ :


```cpp
hittable_list random_scene() {
    hittable_list world;

    /* ìˆ˜ì • */
    auto checker = make_shared<checker_texture>(color(0.2, 0.3, 0.1), color(0.9, 0.9, 0.9));
    world.add(make_shared<sphere>(point3(0,-1000,0), 1000, make_shared<lambertian>(checker)));
    /*******/

    for (int a = -11; a < 11; a++) {
        ...
```

**ëª©ë¡ 26 :** [main.cc] ì‚¬ìš©ì¤‘ì¸ ì²´í¬ ë¬´ëŠ¬ í…ìŠ¤ì²˜

ì ìš© :


[![img](https://raytracing.github.io/images/img-2.02-checker-ground.png)](https://raytracing.github.io/images/img-2.02-checker-ground.png)

*ì´ë¯¸ì§€ 2 : ì²´í¬ ë¬´ëŠ¬ ë°”ë‹¥ì—ìˆëŠ” êµ¬ì²´*

## 4.4 ì²´í¬ ë¬´ëŠ¬ í…ìŠ¤ì²˜ë¡œ ì¥ë©´ ë Œë”ë§

í”„ë¡œê·¸ë¨ì— ë‘ ë²ˆì§¸ ì¥ë©´ì„ ì¶”ê°€í•˜ê³  ê·¸ ì´í›„ì— ì´ ì±…ì„ ì§„í–‰í•˜ë©´ì„œ ë” ë§ì€ ì¥ë©´ì„ ì¶”ê°€ í•  ê²ƒì…ë‹ˆë‹¤. ì´ë¥¼ ë•ê¸° ìœ„í•´ ì£¼ì–´ì§„ ì‹¤í–‰ì— ëŒ€í•´ ì›í•˜ëŠ” ì¥ë©´ì„ ì„ íƒí•˜ëŠ” í•˜ë“œ ì½”ë”© ëœ switch ë¬¸ì„ ì„¤ì •í•©ë‹ˆë‹¤. ë¶„ëª…íˆ ì´ê²ƒì€ ì¡°ì¡í•œ ì ‘ê·¼ ë°©ì‹ì´ì§€ë§Œ ìš°ë¦¬ëŠ” ì¼ì„ ë‹¨ìˆœí•˜ê²Œ ìœ ì§€í•˜ê³  ë ˆì´íŠ¸ ë ˆì´ì‹±ì— ì§‘ì¤‘í•˜ë ¤ê³  ë…¸ë ¥í•˜ê³  ìˆìŠµë‹ˆë‹¤. ìì‹ ì˜ ë ˆì´íŠ¸ ë ˆì´ì„œì—ì„œ ë‹¤ë¥¸ ì ‘ê·¼ ë°©ì‹ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì¥ë©´ êµ¬ì„± ê¸°ëŠ¥ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.


```cpp
hittable_list two_spheres() {
    hittable_list objects;

    auto checker = make_shared<checker_texture>(color(0.2, 0.3, 0.1), color(0.9, 0.9, 0.9));

    objects.add(make_shared<sphere>(point3(0,-10, 0), 10, make_shared<lambertian>(checker)));
    objects.add(make_shared<sphere>(point3(0, 10, 0), 10, make_shared<lambertian>(checker)));

    return objects;
}
```

**ëª©ë¡ 27 :** [main.cc] ë‘ ê°œì˜ ì²´í¬ ë¬´ëŠ¬ êµ¬ê°€ìˆëŠ” ì¥ë©´



ë‹¤ìŒ ë³€ê²½ ì‚¬í•­ì€ ì£¼ìš” ê¸°ëŠ¥ì„ ì„¤ì •í•©ë‹ˆë‹¤.



```cpp
// World


hittable_list world;

point3 lookfrom;
point3 lookat;
auto vfov = 40.0;
auto aperture = 0.0;

switch (0) {
    case 1:
        world = random_scene();
        lookfrom = point3(13,2,3);
        lookat = point3(0,0,0);
        vfov = 20.0;
        aperture = 0.1;
        break;

    default:
    case 2:
        world = two_spheres();
        lookfrom = point3(13,2,3);
        lookat = point3(0,0,0);
        vfov = 20.0;
        break;
}

// Camera

vec3 vup(0,1,0);
auto dist_to_focus = 10.0;
int image_height = static_cast<int>(image_width / aspect_ratio);

camera cam(lookfrom, lookat, vup, vfov, aspect_ratio, aperture, dist_to_focus, 0.0, 1.0);
...
```

**ëª©ë¡ 28 :** [main.cc] ë‘ ë²ˆì§¸ ì¥ë©´

ê²°ê³¼ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.


[![img](https://raytracing.github.io/images/img-2.03-checker-spheres.png)](https://raytracing.github.io/images/img-2.03-checker-spheres.png)

*ì´ë¯¸ì§€ 3 : ì²´í¬ ë¬´ëŠ¬ êµ¬*

