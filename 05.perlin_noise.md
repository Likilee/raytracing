
# 5. Perlin ë…¸ì´ì¦ˆ


ë©‹ì§€ê²Œ ë³´ì´ëŠ” ë‹¨ë‹¨í•œ ì§ˆê°ì„ ì–»ê¸° ìœ„í•´ ëŒ€ë¶€ë¶„ì˜ ì‚¬ëŒë“¤ì€ Perlin ë…¸ì´ì¦ˆë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ë“¤ì€ ë°œëª…ê°€ Ken Perlinì˜ ì´ë¦„ì„ ë”°ì„œ ëª…ëª…ë˜ì—ˆìŠµë‹ˆë‹¤. Perlin í…ìŠ¤ì²˜ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë°±ìƒ‰ ë…¸ì´ì¦ˆë¥¼ ë°˜í™˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.


[![img](https://raytracing.github.io/images/img-2.04-white-noise.jpg)](https://raytracing.github.io/images/img-2.04-white-noise.jpg)

*ì´ë¯¸ì§€ 4 : ë°±ìƒ‰ ì¡ìŒ*


ëŒ€ì‹  íë¦¼ì´ ì ìš©ëœ ë°±ìƒ‰ ì¡ìŒê³¼ ë¹„ìŠ·í•œ ê²ƒì„ ë°˜í™˜í•©ë‹ˆë‹¤.


[![img](https://raytracing.github.io/images/img-2.05-white-noise-blurred.jpg)](https://raytracing.github.io/images/img-2.05-white-noise-blurred.jpg)

*ì´ë¯¸ì§€ 5 : ë°±ìƒ‰ ì¡ìŒ, íë¦¿í•¨*


Perlin ë…¸ì´ì¦ˆì˜ í•µì‹¬ ë¶€ë¶„ì€ ë°˜ë³µ ê°€ëŠ¥í•˜ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. 3D í¬ì¸íŠ¸ë¥¼ ì…ë ¥ìœ¼ë¡œ ì‚¬ìš©í•˜ê³  í•­ìƒ ë™ì¼í•œ ì„ì˜ì˜ ìˆ«ìë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ì£¼ë³€ ì§€ì ì€ ë¹„ìŠ·í•œ ìˆ«ìë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. Perlin ë…¸ì´ì¦ˆì˜ ë˜ ë‹¤ë¥¸ ì¤‘ìš”í•œ ë¶€ë¶„ì€ ê°„ë‹¨í•˜ê³  ë¹ ë¥´ë¯€ë¡œ ì¼ë°˜ì ìœ¼ë¡œ í•´í‚¹ìœ¼ë¡œ ìˆ˜í–‰ë©ë‹ˆë‹¤. Andrew Kenslerì˜ ì„¤ëª…ì— ë”°ë¼ ì ì§„ì ìœ¼ë¡œ í•´í‚¹ì„ êµ¬ì¶•í•˜ê² ìŠµë‹ˆë‹¤.


## 5.1 ë‚œìˆ˜ ë¸”ë¡ ì‚¬ìš©

ë‚œìˆ˜ì˜ 3D ë°°ì—´ë¡œ ëª¨ë“  ê³µê°„ì„ íƒ€ì¼ë§í•˜ê³  ë¸”ë¡ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë°˜ë³µì´ ëª…í™•í•œ ê³³ì—ì„œ ë¬´ì–¸ê°€ë¥¼ ì–»ìŠµë‹ˆë‹¤.

[![img](https://raytracing.github.io/images/img-2.06-tile-random.jpg)](https://raytracing.github.io/images/img-2.06-tile-random.jpg)

*ì´ë¯¸ì§€ 6 : ë°”ë‘‘íŒ ì‹ ë¬´ì‘ìœ„ íŒ¨í„´*

íƒ€ì¼ë§ ëŒ€ì‹  ì¼ì¢…ì˜ í•´ì‹±ì„ ì‚¬ìš©í•˜ì—¬ì´ë¥¼ ìŠ¤í¬ë¨ë¸” í•´ ë³´ê² ìŠµë‹ˆë‹¤. ì´ ëª¨ë“  ê²ƒì„ ê°€ëŠ¥í•˜ê²Œí•˜ëŠ” ì•½ê°„ì˜ ì§€ì› ì½”ë“œê°€ ìˆìŠµë‹ˆë‹¤.


```cpp
#ifndef PERLIN_H
#define PERLIN_H

#include "rtweekend.h"

class perlin {
    public:
        perlin() {
            ranfloat = new double[point_count];
            for (int i = 0; i < point_count; ++i) {
                ranfloat[i] = random_double();
            }

            perm_x = perlin_generate_perm();
            perm_y = perlin_generate_perm();
            perm_z = perlin_generate_perm();
        }

        ~perlin() {
            delete[] ranfloat;
            delete[] perm_x;
            delete[] perm_y;
            delete[] perm_z;
        }

        double noise(const point3& p) const {
            auto i = static_cast<int>(4*p.x()) & 255;
            auto j = static_cast<int>(4*p.y()) & 255;
            auto k = static_cast<int>(4*p.z()) & 255;

            return ranfloat[perm_x[i] ^ perm_y[j] ^ perm_z[k]];
        }

    private:
        static const int point_count = 256;
        double* ranfloat;
        int* perm_x;
        int* perm_y;
        int* perm_z;

        static int* perlin_generate_perm() {
            auto p = new int[point_count];

            for (int i = 0; i < perlin::point_count; i++)
                p[i] = i;

            permute(p, point_count);

            return p;
        }

        static void permute(int* p, int n) {
            for (int i = n-1; i > 0; i--) {
                int target = random_int(0, i);
                int tmp = p[i];
                p[i] = p[target];
                p[target] = tmp;
            }
        }
};

#endif
```

**ëª©ë¡ 29 :** [perlin.h] Perlin í…ìŠ¤ì²˜ í´ë˜ìŠ¤ ë° í•¨ìˆ˜



ì´ì œ 0ê³¼ 1 ì‚¬ì´ì˜ í”Œë¡œíŠ¸ë¥¼ ê°€ì ¸ì™€ íšŒìƒ‰ ìƒ‰ìƒì„ ë§Œë“œëŠ” ì‹¤ì œ í…ìŠ¤ì²˜ë¥¼ ë§Œë“œëŠ” ê²½ìš° :


```cpp
#include "perlin.h"

class noise_texture : public texture {
    public:
        noise_texture() {}

        virtual color value(double u, double v, const point3& p) const override {
            return color(1,1,1) * noise.noise(p);
        }

    public:
        perlin noise;
};
```

**ëª©ë¡ 30 :** [texture.h] ë…¸ì´ì¦ˆ í…ìŠ¤ì²˜



ì´ í…ìŠ¤ì²˜ë¥¼ ì¼ë¶€ êµ¬ì²´ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```cpp
hittable_list two_perlin_spheres() {
    hittable_list objects;

    auto pertext = make_shared<noise_texture>();
    objects.add(make_shared<sphere>(point3(0,-1000,0), 1000, make_shared<lambertian>(pertext)));
    objects.add(make_shared<sphere>(point3(0, 2, 0), 2, make_shared<lambertian>(pertext)));

    return objects;
}
```

**ëª©ë¡ 31 :** [main.cc] ë‘ ê°œì˜ Perlin í…ìŠ¤ì²˜ êµ¬ê°€ìˆëŠ” ì¥ë©´


ì´ì „ê³¼ ìœ ì‚¬í•œ ì¥ë©´ ì„¤ì • :


```cpp
int main() {
    ...
    switch (0) {
        ...
        default:        case 2:
            ...

        default:
        case 3:
            world = two_perlin_spheres();
            lookfrom = point3(13,2,3);
            lookat = point3(0,0,0);
            vfov = 20.0;
            break;    }
    ...
```

**ëª©ë¡ 32 :** [main.cc] ë§¤ê°œ ë³€ìˆ˜ë³´ê¸°


í•´ì‹±ì„ ì¶”ê°€í•˜ë©´ ì›í•˜ëŠ”ëŒ€ë¡œ ìŠ¤í¬ë¨ë¸”ë©ë‹ˆë‹¤.


[![img](https://raytracing.github.io/images/img-2.07-hash-random.png)](https://raytracing.github.io/images/img-2.07-hash-random.png)

*ì´ë¯¸ì§€ 7 : í•´ì‹œ ëœ ì„ì˜ í…ìŠ¤ì²˜*





## 5.2 ê²°ê³¼ ë‹¤ë“¬ê¸°



ë§¤ë„ëŸ½ê²Œ ë§Œë“¤ê¸° ìœ„í•´ ì„ í˜•ìœ¼ë¡œ ë³´ê°„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.



```cpp
class perlin {
    public:
        ...
        double noise(point3 vec3& p) const {
            /* ì¶”ê°€ */
            auto u = p.x() - floor(p.x());
            auto v = p.y() - floor(p.y());
            auto w = p.z() - floor(p.z());

            auto i = static_cast<int>(floor(p.x()));
            auto j = static_cast<int>(floor(p.y()));
            auto k = static_cast<int>(floor(p.z()));
            double c[2][2][2];

            for (int di=0; di < 2; di++)
                for (int dj=0; dj < 2; dj++)
                    for (int dk=0; dk < 2; dk++)
                        c[di][dj][dk] = ranfloat[
                            perm_x[(i+di) & 255] ^
                            perm_y[(j+dj) & 255] ^
                            perm_z[(k+dk) & 255]
                        ];

            return trilinear_interp(c, u, v, w);
            /*******/
        }
        ...
    private:
        ...
        /* ì¶”ê°€ */
        static double trilinear_interp(double c[2][2][2], double u, double v, double w) {
            auto accum = 0.0;
            for (int i=0; i < 2; i++)
                for (int j=0; j < 2; j++)
                    for (int k=0; k < 2; k++)
                        accum += (i*u + (1-i)*(1-u))*
                                (j*v + (1-j)*(1-v))*
                                (k*w + (1-k)*(1-w))*c[i][j][k];

            return accum;
        }
        /*******/
    }
```

**ëª©ë¡ 33 :** [perlin.h] trilienear ë³´ê°„ì„ ì‚¬ìš©í•œ Perlin

ê²°ê³¼ :

[![img](https://raytracing.github.io/images/img-2.08-perlin-trilerp.png)](https://raytracing.github.io/images/img-2.08-perlin-trilerp.png)

*ì´ë¯¸ì§€ 8 : ì‚¼ì„  í˜• ë³´ê°„ì„ ì‚¬ìš©í•œ Perlin í…ìŠ¤ì²˜*


## 5.3 Hermitian Smoothingìœ¼ë¡œ ê°œì„ 

í‰í™œí™”ëŠ” ê°œì„  ëœ ê²°ê³¼ë¥¼ ì‚°ì¶œí•˜ì§€ë§Œ ê±°ê¸°ì—ëŠ” ëª…ë°±í•œ ê·¸ë¦¬ë“œ ê¸°ëŠ¥ì´ ìˆìŠµë‹ˆë‹¤. ê·¸ì¤‘ ì¼ë¶€ëŠ” ìƒ‰ìƒì˜ ì„ í˜• ë³´ê°„ì˜ ì•Œë ¤ì§„ ì§€ê° ì¸ê³µë¬¼ ì¸ ë§ˆí•˜ ë°´ë“œì…ë‹ˆë‹¤. í‘œì¤€ íŠ¸ë¦­ì€ ë³´ê°„ì„ ë°˜ì˜¬ë¦¼í•˜ê¸° ìœ„í•´ Hermite íë¹…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.


```cpp
class perlin (
    public:
        ...
        double noise(const point3& p) const {
            auto u = p.x() - floor(p.x());
            auto v = p.y() - floor(p.y());
            auto w = p.z() - floor(p.z());

            /* ìˆ˜ì • */
            u = u*u*(3-2*u);
            v = v*v*(3-2*v);
            w = w*w*(3-2*w);
            /*******/
            auto i = static_cast<int>(floor(p.x()));
            auto j = static_cast<int>(floor(p.y()));
            auto k = static_cast<int>(floor(p.z()));
            ...
```

**ëª©ë¡ 34 :** [perlin.h] Perlin ìŠ¤ë¬´ë”©


ì´ê²ƒì€ ë” ë§¤ë„ëŸ½ê²Œ ë³´ì´ëŠ” ì´ë¯¸ì§€ë¥¼ ì œê³µí•©ë‹ˆë‹¤.


[![img](https://raytracing.github.io/images/img-2.09-perlin-trilerp-smooth.png)](https://raytracing.github.io/images/img-2.09-perlin-trilerp-smooth.png)

*ì´ë¯¸ì§€ 9 : Perlin í…ìŠ¤ì²˜, ì‚¼ì„  í˜• ë³´ê°„, ìŠ¤ë¬´ë”©*


## 5.4 ì£¼íŒŒìˆ˜ ì¡°ì •

ë˜í•œ ì•½ê°„ ë‚®ì€ ì£¼íŒŒìˆ˜ì…ë‹ˆë‹¤. ì…ë ¥ í¬ì¸íŠ¸ì˜ í¬ê¸°ë¥¼ ì¡°ì •í•˜ì—¬ ë” ë¹ ë¥´ê²Œ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```cpp
class noise_texture : public texture {
    public:
        noise_texture() {}
        /* ìˆ˜ì • */
        noise_texture(double sc) : scale(sc) {}
        /*******/
        virtual color value(double u, double v, const point3& p) const override {
            /* ìˆ˜ì • */
            return color(1,1,1) * noise.noise(scale * p);
            /*******/
        }

    public:
        perlin noise;
        /* ì¶”ê°€ */
        double scale;
        /*******/
    };
```

**ëª©ë¡ 35 :** [texture.h] Perlin í‰í™œí™”, ë” ë†’ì€ ë¹ˆë„

ê·¸ëŸ° ë‹¤ìŒ í•´ë‹¹ ë°°ìœ¨ì„ `two_perlin_spheres()`ì¥ë©´ ì„¤ëª…ì— ì¶”ê°€í•©ë‹ˆë‹¤ .


```cpp
hittable_list two_perlin_spheres() {
    hittable_list objects;

    /* ì¶”ê°€ */
    auto pertext = make_shared<noise_texture>(4);
    /*******/
    objects.add(make_shared<sphere>(point3(0,-1000,0), 1000, make_shared<lambertian>(pertext)));
    objects.add(make_shared<sphere>(point3(0, 2, 0), 2, make_shared<lambertian>(pertext)));

    return objects;
}
```

**Listing 36 :** [main.cc] ë…¸ì´ì¦ˆì— ëŒ€í•œ ìŠ¤ì¼€ì¼ì´ìˆëŠ” Perlin í…ìŠ¤ì²˜ êµ¬ì²´


ë‹¤ìŒì„ ì œê³µí•©ë‹ˆë‹¤ :


[![img](https://raytracing.github.io/images/img-2.10-perlin-hifreq.png)](https://raytracing.github.io/images/img-2.10-perlin-hifreq.png)

*ì´ë¯¸ì§€ 10 : Perlin í…ìŠ¤ì²˜, ë” ë†’ì€ ë¹ˆë„*


## 5.5 ê²©ì ì ì—ì„œ ëœë¤ ë²¡í„° ì‚¬ìš©


íŒ¨í„´ì˜ ìµœì†Œê°’ê³¼ ìµœëŒ€ ê°’ì´ í•­ìƒ ì •ìˆ˜ x / y / zì— ì •í™•íˆ ìœ„ì¹˜í•˜ê¸° ë•Œë¬¸ì— ì´ê²ƒì€ ì—¬ì „íˆ â€‹â€‹ì•½ê°„ ë­‰íˆ­í•œ ëª¨ì–‘ì…ë‹ˆë‹¤. Ken Perlinì˜ ë§¤ìš° ì˜ë¦¬í•œ íŠ¸ë¦­ì€ ê²©ì ì ì— ë¶€ë™ ë‹¨ìœ„ ë²¡í„° ëŒ€ì‹  ì„ì˜ì˜ ë‹¨ìœ„ ë²¡í„°ë¥¼ ë°°ì¹˜í•˜ê³  ë‚´ì ì„ ì‚¬ìš©í•˜ì—¬ ê²©ìì—ì„œ ìµœì†Œ ë° ìµœëŒ€ë¥¼ ì´ë™í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ë”°ë¼ì„œ ë¨¼ì € ì„ì˜ì˜ ë¶€ë™ ì†Œìˆ˜ì ì„ ì„ì˜ì˜ ë²¡í„°ë¡œ ë³€ê²½í•´ì•¼í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ë²¡í„°ëŠ” í•©ë¦¬ì ì¸ ë¶ˆê·œì¹™í•œ ë°©í–¥ ì§‘í•©ì´ë©° ì •í™•í•˜ê²Œ ê· ì¼í•˜ê²Œ ë§Œë“¤ì§€ ì•ŠìŠµë‹ˆë‹¤.


```cpp
class perlin {
    public:
        perlin() {
            /* ì¶”ê°€ */
            ranvec = new vec3[point_count];
            /*******/
            for (int i = 0; i < point_count; ++i) {
                /* ìˆ˜ì • */
                ranvec[i] = unit_vector(vec3::random(-1,1));
                /*******/
            }

            perm_x = perlin_generate_perm();
            perm_y = perlin_generate_perm();
            perm_z = perlin_generate_perm();
        }

        ~perlin() {
            /* ì¶”ê°€ */
            delete[] ranvec;
            /*******/
            delete[] perm_x;
            delete[] perm_y;
            delete[] perm_z;
        }
    ...
    private:
        static const int point_count = 256;
        /* ì¶”ê°€ */
        vec3* ranvec;
        /*******/
        int* perm_x;
        int* perm_y;
        int* perm_z;
        ...
}
```

**ëª©ë¡ 37 :** [perlin.h] ë¬´ì‘ìœ„ ë‹¨ìœ„ ë³€í™˜ì´ìˆëŠ” Perlin

Perlin í´ë˜ìŠ¤ì˜ `noise()`ë©”ì„œë“œëŠ” ì´ì œ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.


```cpp
class perlin {
    public:
        ...
        double noise(const point3& p) const {
            /* ìˆ˜ì • */
            auto u = p.x() - floor(p.x());
            auto v = p.y() - floor(p.y());
            auto w = p.z() - floor(p.z());
            /*******/
            auto i = static_cast<int>(floor(p.x()));
            auto j = static_cast<int>(floor(p.y()));
            auto k = static_cast<int>(floor(p.z()));
            /* ì¶”ê°€ */
            vec3 c[2][2][2];
            /*******/
            for (int di=0; di < 2; di++)
                for (int dj=0; dj < 2; dj++)
                    for (int dk=0; dk < 2; dk++)
            /* ìˆ˜ì • */
                        c[di][dj][dk] = ranvec[
                            perm_x[(i+di) & 255] ^
                            perm_y[(j+dj) & 255] ^
                            perm_z[(k+dk) & 255]
                        ];

            return perlin_interp(c, u, v, w);
            /********/
        }
        ...
    }
```

**ëª©ë¡ 38 :** [perlin.h] ìƒˆë¡œìš´ noise () ë©”ì„œë“œê°€ìˆëŠ” Perlin í´ë˜ìŠ¤


ê·¸ë¦¬ê³  interpolationì€ ì¡°ê¸ˆ ë” ë³µì¡í•´ì§‘ë‹ˆë‹¤.

```cpp
class perlin {
    ...
    private:
        ...
        static double perlin_interp(vec3 c[2][2][2], double u, double v, double w) {
            /* ì¶”ê°€ */
            auto uu = u*u*(3-2*u);
            auto vv = v*v*(3-2*v);
            auto ww = w*w*(3-2*w);
            auto accum = 0.0;

            for (int i=0; i < 2; i++)
                for (int j=0; j < 2; j++)
                    for (int k=0; k < 2; k++) {
                        vec3 weight_v(u-i, v-j, w-k);
                        accum += (i*uu + (1-i)*(1-uu))
                               * (j*vv + (1-j)*(1-vv))
                               * (k*ww + (1-k)*(1-ww))
                               * dot(c[i][j][k], weight_v);
                    }

            return accum;
            /*******/
        }
        ...
}
```

**ëª©ë¡ 39 :** [perlin.h] ì§€ê¸ˆê¹Œì§€ì˜ Perlin interpolation í•¨ìˆ˜

perlin í•´ì„ì˜ ì¶œë ¥ì€ ìŒìˆ˜ ê°’ì„ ë°˜í™˜ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ìŒìˆ˜ ê°’ì€ ê°ë§ˆ í•¨ìˆ˜ì˜ sqrt () í•¨ìˆ˜ì— ì „ë‹¬ë˜ì–´ NaNìœ¼ë¡œ ë³€í™˜ë©ë‹ˆë‹¤. perlin ì¶œë ¥ì„ 0ê³¼ 1 ì‚¬ì´ë¡œ ë‹¤ì‹œ ìºìŠ¤íŒ…í•©ë‹ˆë‹¤.


```cpp
class noise_texture : public texture {
    public:
        noise_texture() {}
        noise_texture(double sc) : scale(sc) {}

        virtual color value(double u, double v, const point3& p) const override {
            /* ìˆ˜ì • */
            return color(1,1,1) * 0.5 * (1.0 + noise.noise(scale * p));
            /*******/
        }

    public:
        perlin noise;
        double scale;
};
```

**ëª©ë¡ 40 :** [texture.h] Perlin í‰í™œí™”, ë” ë†’ì€ ë¹ˆë„


ì´ê²ƒì€ ë§ˆì¹¨ë‚´ ë” í•©ë¦¬ì ìœ¼ë¡œ ë³´ì´ëŠ” ê²ƒì„ ì œê³µí•©ë‹ˆë‹¤.

[![img](https://raytracing.github.io/images/img-2.11-perlin-shift.png)](https://raytracing.github.io/images/img-2.11-perlin-shift.png)

*ì´ë¯¸ì§€ 11 : Perlin í…ìŠ¤ì²˜, ì •ìˆ˜ ê°’ì—ì„œ ì´ë™*



## 5.6 ë‚œê¸°ë¥˜ ì†Œê°œ

ë§¤ìš° ìì£¼, ì—¬ëŸ¬ í•©ì‚° ëœ ì£¼íŒŒìˆ˜ë¥¼ ê°€ì§„ í•©ì„± ì¡ìŒì´ ì‚¬ìš©ë©ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ë‚œë¥˜ë¼ê³ í•˜ë©° ì¡ìŒì— ëŒ€í•œ ë°˜ë³µ í˜¸ì¶œì˜ í•©ê³„ì…ë‹ˆë‹¤.


```cpp
class perlin {
    ...
    public:
        ...
        double turb(const point3& p, int depth=7) const {
            auto accum = 0.0;
            auto temp_p = p;
            auto weight = 1.0;

            for (int i = 0; i < depth; i++) {
                accum += weight*noise(temp_p);
                weight *= 0.5;
                temp_p *= 2;
            }

            return fabs(accum);
        }
        ...
```

**ëª©ë¡ 41 :** [perlin.h] ë‚œë¥˜ í•¨ìˆ˜


ì—¬ê¸°ì„œ `fabs()`ëŠ” <cmath>ì— ì •ì˜ ëœ ì ˆëŒ€ ê°’ í•¨ìˆ˜ì…ë‹ˆë‹¤.


```cpp
class noise_texture : public texture {
    public:
        noise_texture() {}
        noise_texture(double sc) : scale(sc) {}

        virtual color value(double u, double v, const point3& p) const override {
            /* ìˆ˜ì • */
            return color(1,1,1) * noise.turb(scale * p);
            /*******/
        }

    public:
        perlin noise;
        double scale;
};
```

**ëª©ë¡ 42 :** [texture.h] ë‚œë¥˜ê°€ìˆëŠ” ë…¸ì´ì¦ˆ í…ìŠ¤ì²˜


ì§ì ‘ ì‚¬ìš©í•˜ë©´ ë‚œë¥˜ëŠ” ì¼ì¢…ì˜ ìœ„ì¥ ê·¸ë¬¼ ëª¨ì–‘ì„ ì œê³µí•©ë‹ˆë‹¤.


[![img](https://raytracing.github.io/images/img-2.12-perlin-turb.png)](https://raytracing.github.io/images/img-2.12-perlin-turb.png)

*ì´ë¯¸ì§€ 12 : ë‚œë¥˜ê°€ìˆëŠ” Perlin í…ìŠ¤ì²˜*


## 5.7 ìœ„ìƒ ì¡°ì •

ê·¸ëŸ¬ë‚˜ ì¼ë°˜ì ìœ¼ë¡œ ë‚œë¥˜ëŠ” ê°„ì ‘ì ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì ˆì°¨ ì  ì†”ë¦¬ë“œ í…ìŠ¤ì²˜ì˜ "hello world"ê°™ì€ ì¡´ì¬ê°€ ëŒ€ë¦¬ì„ê³¼ ê°™ì€ í…ìŠ¤ì²˜ì…ë‹ˆë‹¤. ê¸°ë³¸ ì•„ì´ë””ì–´ëŠ” ì‚¬ì¸ í•¨ìˆ˜ì™€ ê°™ì€ ê²ƒì— ë¹„ë¡€í•˜ëŠ” ìƒ‰ìƒì„ ë§Œë“¤ê³  ë‚œë¥˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ìœ„ìƒì„ ì¡°ì •í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤ (ê·¸ë˜ì„œ ì¤„ë¬´ëŠ¬ê°€ ë¬¼ê²° ëª¨ì–‘ìœ¼ë¡œ ë§Œë“œëŠ” ğ‘¥ ë¥¼ sin(ğ‘¥)ìœ¼ë¡œ ì´ë™). ì§ì„  ë…¸ì´ì¦ˆì™€ ë‚œë¥˜ë¥¼ ì£¼ì„ ì²˜ë¦¬í•˜ê³  ëŒ€ë¦¬ì„ê³¼ ê°™ì€ íš¨ê³¼ë¥¼ ì£¼ëŠ” ê²ƒì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.


```cpp
class noise_texture : public texture {
    public:
        noise_texture() {}
        noise_texture(double sc) : scale(sc) {}

        virtual color value(double u, double v, const point3& p) const override {
            /* ìˆ˜ì • */
            return color(1,1,1) * 0.5 * (1 + sin(scale*p.z() + 10*noise.turb(p)));
            /*******/
        }

    public:
        perlin noise;
        double scale;
};
```

**ëª©ë¡ 43 :** [texture.h] ëŒ€ë¦¬ì„ í…ìŠ¤ì²˜ê°€ìˆëŠ” ë…¸ì´ì¦ˆ í…ìŠ¤ì²˜

ê²°ê³¼ :

[![img](https://raytracing.github.io/images/img-2.13-perlin-marble.png)](https://raytracing.github.io/images/img-2.13-perlin-marble.png)

*ì´ë¯¸ì§€ 13 : Perlin ë…¸ì´ì¦ˆ, ëŒ€ë¦¬ì„ ì§ˆê°*

